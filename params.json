{"name":"ExpressionReflect","tagline":"Provides the ability to \"compile\" expressions to delegates without using Reflection.Emit but only using reflection.","body":"ExpressionReflect\r\n=================\r\n\r\nWhy?\r\n----\r\n\r\nProvides the ability to \"compile\" expressions to delegates without using Reflection.Emit but only using reflection.\r\nThe created delegate will make use of reflection to execute the expression when it is invoked. This is much slower\r\nthan executing a compiled delegate of an expression!\r\n\r\nThis framework is intended to be used where dynamic code creation is not possible. The main purpose is the useage with\r\nXamarin.iOS due to it's restriction on Reflection.Emit.\r\n\r\nHow?\r\n----\r\n\r\nThe expression tree is traversed and respective reflection calls are created and invoked. This is very slow compared \r\nto compiled expressions, so it should only be used with simple expressions.\r\n\r\nUsage\r\n-----\r\n\r\nThe usage is fairly simple. It's just an extension method on a expression.\r\n\r\n```csharp\r\nExpression<Func<Customer, string>> expression = x => x.Firstname;\r\nFunc<Customer, string> reflection = expression.Reflect();\r\nstring result = reflection.Invoke(customer);\r\n```\r\n\r\nThe extension method `Reflect()` will return a delegate that will execute the reflection-based expression evaluation\r\ninternally.\r\n\r\nWhat is supported?\r\n------------------\r\n\r\nThe following built-in delegates are supported at the moment:\r\n\r\n* `Func<T, TResult>` (all variations)\r\n* `Action` und `Action<T>` (all variations)\r\n* `Predicate<T>`\r\n\r\nThe following expression types are supported at the moment:\r\n\r\n* Property getter\r\n```csharp\r\nx => x.Firstname\r\n```\r\n\r\n* Property getter with subsequent method call\r\n```csharp\r\nx => x.Firstname.ToLower();\r\n```\r\n\r\n* Method call with return value\r\nx => x.CalculateAge()\r\n```\r\n\r\n* Method call with return value and subsequent method call\r\n```csharp\r\nx => x.ToString().ToLower();\r\n```\r\n\r\n* Method call with return value and expression parameters\r\n```csharp\r\nx => x.CalculateLength(x.Firstname);\r\n```\r\n\r\n* Method call with return value, expression parameters and binary expression\r\n```csharp\r\nx => x.Calculate(x.Age + x.Value);\r\n```\r\n\r\n* Method call with return value, expression parameters, binary expression and constant\r\n```csharp\r\nx => x.Calculate(x.Age + 100);\r\n```\r\n\r\n* Method call with return value, expression parameters, binary expression and local variable\r\n```csharp\r\nint value = 666;\r\nx => x.Calculate(value);\r\n```\r\n\r\n* Method call with return value, expression parameters and nested constructor call.\r\n```csharp\r\nint value = 666;\r\nx => x.Calculate(new Customer(value));\r\n```\r\n\r\n* Method call with return value, expression parameters and nested method call.\r\n```csharp\r\nx.Calculate(x.CalculateAge());\r\n```\r\n\r\n* Method call with return value, expression parameters and local delegate call.\r\n```csharp\r\nFunc<int> method = () => 100;\r\nx => x.Calculate(method());\r\n```\r\n\r\n* Method call with return value, expression parameters and local delegate call with parameters.\r\n```csharp\r\nFunc<int, int> method = x => x + 100;\r\nx => x.Calculate(method(10));\r\n```\r\n\r\n* Method call with return value and mixed parameters\r\n```csharp\r\nx => x.CalculateLength(x.Firstname, x, 10);\r\n```\r\n\r\n* Constructor call\r\n```csharp\r\nx => new Customer();\r\n```\r\n\r\n* Constructor call with subsequent method call\r\n```csharp\r\nx => new Customer();\r\n```\r\n\r\n* Constructor call with expression parameters\r\n```csharp\r\nx => new Customer(x.Lastname, x.Firstname);\r\n```\r\n\r\n* Constructor call with expression parameters and binary expression\r\n```csharp\r\nx => new Customer(x.Age + x.Value);\r\n```\r\n\r\n* Constructor call with expression parameters, binary expression and constant\r\n```csharp\r\nx => new Customer(x.Age + 100);\r\n```\r\n\r\n* Constructor call with expression parameters, binary expression and local variable \r\n```csharp\r\nint value = 666;\r\nx => new Customer(value);\r\n```\r\n\r\n* Constructor call with expression parameters and nested costructor call\r\n```csharp\r\nint value = 666;\r\nx => new Customer(new Customer(value));\r\n```\r\n\r\n* Constructor call with expression parameters and nested method call.\r\n```csharp\r\nx => new Customer(x.CalculateAge());\r\n```\r\n\r\n* Constructor call with expression parameters and local delegate call.\r\n```csharp\r\nFunc<int> method = () => 100;\r\nx => new Customer(method());\r\n```\r\n\r\n* Constructor call with expression parameters and local delegate call with parameters.\r\n```csharp\r\nFunc<int, int> method = x => x + 100;\r\nx => new Customer(method(10));\r\n```\r\n\r\n* Constructor call with mixed parameters\r\n```csharp\r\nx => new Customer(x.Lastname, x, 10, x.Firstname);\r\n```\r\n\r\nSupported features\r\n------------------\r\n\r\n* `Func<T, TResult>`\r\n* `Action` und `Action<T>`\r\n* `Predicate<T>`\r\n* Property getters including indexers\r\n* Field access\r\n* Method calls with mixed parameters\r\n* Constructor invocations with mixed parameters\r\n* Local variables\r\n* Constant expressions\r\n* Local delegates\r\n* Local delegates with parameters (local and constant, binary expression)\r\n* Binary expressions including 'is' operator\r\n* Unary expressions (almost complete)\r\n* Array access\r\n* Array creation (simple arrays)\r\n* Object initializers (objects, lists, dictionaries)\r\n* Ternary conditionals\r\n* Nested expressions (f.e. LINQ extension methods: `x => x.FirstOrDefault(y.Name == \"John\")`)\r\n\r\nAll this features can be combined to more complex expressions.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}